import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { WebSocketServer } from "ws";
import Stripe from "stripe";

if (!process.env.STRIPE_SECRET_KEY) {
  console.warn('Missing required Stripe secret: STRIPE_SECRET_KEY');
}

const stripe = process.env.STRIPE_SECRET_KEY 
  ? new Stripe(process.env.STRIPE_SECRET_KEY) 
  : null;

export async function registerRoutes(app: Express): Promise<Server> {
  const httpServer = createServer(app);
  
  // Initialize WebSocket server for real-time updates
  const wss = new WebSocketServer({ server: httpServer });
  
  // WebSocket connection handler
  wss.on("connection", (ws) => {
    console.log("New client connected");
    
    // Send initial welcome message
    ws.send(JSON.stringify({ type: "connection", message: "Connected to CryptoPulse WebSocket Server" }));
    
    // Handle client messages
    ws.on("message", (message) => {
      try {
        const parsedMessage = JSON.parse(message.toString());
        console.log("Received message:", parsedMessage);
        
        // Handle different message types
        if (parsedMessage.type === "subscribe") {
          // Subscribe to specific updates (price alerts, portfolio updates, etc.)
          ws.send(JSON.stringify({ 
            type: "subscription", 
            status: "success", 
            channel: parsedMessage.channel 
          }));
        }
      } catch (error) {
        console.error("Error processing message:", error);
        ws.send(JSON.stringify({ type: "error", message: "Invalid message format" }));
      }
    });
    
    // Handle client disconnection
    ws.on("close", () => {
      console.log("Client disconnected");
    });
  });
  
  // API Routes
  
  // User management
  app.post("/api/users", async (req, res) => {
    try {
      const { username, password } = req.body;
      const user = await storage.createUser({ username, password });
      res.json({ id: user.id, username: user.username });
    } catch (error) {
      res.status(400).json({ error: (error as Error).message });
    }
  });
  
  app.get("/api/users/:id", async (req, res) => {
    try {
      const userId = parseInt(req.params.id);
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      
      res.json({ id: user.id, username: user.username });
    } catch (error) {
      res.status(400).json({ error: (error as Error).message });
    }
  });
  
  // Portfolio management
  app.post("/api/portfolio", async (req, res) => {
    try {
      const { userId, assets } = req.body;
      // In a real app, we would save this to a database
      // For now, just return success
      res.json({ success: true, userId, assetCount: assets.length });
    } catch (error) {
      res.status(400).json({ error: (error as Error).message });
    }
  });
  
  // Alert system
  app.post("/api/alerts", async (req, res) => {
    try {
      const { userId, alerts } = req.body;
      // In a real app, we would save this to a database
      // For now, just return success
      res.json({ success: true, userId, alertCount: alerts.length });
    } catch (error) {
      res.status(400).json({ error: (error as Error).message });
    }
  });
  
  // Gemini AI proxy
  app.post("/api/generate-ai-response", async (req, res) => {
    try {
      const { prompt, model, language } = req.body;
      
      // In a real app, we would call the Gemini API here
      // For now, return a mock response to avoid exposing API key
      const mockResponses = {
        "es": "Esta es una respuesta simulada del asistente. En una aplicación real, esto sería generado por Gemini AI basado en tu pregunta.",
        "en": "This is a simulated assistant response. In a real application, this would be generated by Gemini AI based on your question.",
        "pt": "Esta é uma resposta simulada do assistente. Em uma aplicação real, isso seria gerado pelo Gemini AI com base na sua pergunta.",
        "fr": "Ceci est une réponse simulée de l'assistant. Dans une application réelle, ce serait généré par Gemini AI sur la base de votre question."
      };
      
      res.json({ 
        response: mockResponses[language as keyof typeof mockResponses] || mockResponses.es,
        model: model || "gemini-1.5-pro",
        language: language || "es"
      });
    } catch (error) {
      res.status(400).json({ error: (error as Error).message });
    }
  });
  
  // Crypto data proxy to avoid exposing API keys on frontend
  app.get("/api/crypto/market-data", async (req, res) => {
    try {
      const { vs_currency, ids, category, order, per_page, page, sparkline, price_change_percentage } = req.query;
      
      // Construct the URL with query parameters
      const url = new URL("https://api.coingecko.com/api/v3/coins/markets");
      url.searchParams.append("vs_currency", (vs_currency as string) || "usd");
      
      if (ids) url.searchParams.append("ids", ids as string);
      if (category) url.searchParams.append("category", category as string);
      if (order) url.searchParams.append("order", order as string);
      if (per_page) url.searchParams.append("per_page", per_page as string);
      if (page) url.searchParams.append("page", page as string);
      if (sparkline) url.searchParams.append("sparkline", sparkline as string);
      if (price_change_percentage) url.searchParams.append("price_change_percentage", price_change_percentage as string);
      
      // Add API key if available
      const apiKey = process.env.COINGECKO_API_KEY;
      const headers: Record<string, string> = {
        "Content-Type": "application/json",
      };
      
      if (apiKey) {
        headers["x-cg-pro-api-key"] = apiKey;
      }
      
      // Make the request to CoinGecko
      const response = await fetch(url.toString(), { headers });
      
      if (!response.ok) {
        throw new Error(`Error fetching market data: ${response.statusText}`);
      }
      
      const data = await response.json();
      res.json(data);
    } catch (error) {
      res.status(400).json({ error: (error as Error).message });
    }
  });
  
  // News API proxy
  app.get("/api/crypto/news", async (req, res) => {
    try {
      const { category } = req.query;
      
      // Mock news data for demonstration
      const mockNews = [
        {
          id: "1",
          title: "Bitcoin Breaks $60,000 Barrier After ETF Approval",
          summary: "Bitcoin has surged past $60,000 following the SEC's approval of spot Bitcoin ETFs, marking a significant milestone for cryptocurrency adoption.",
          url: "#",
          source: "CryptoNews",
          publishedAt: new Date().toISOString(),
          categories: ["bitcoin", "market", "regulation"],
        },
        {
          id: "2",
          title: "Ethereum Completes Major Network Upgrade",
          summary: "Ethereum has successfully implemented its latest network upgrade, improving scalability and reducing gas fees for transactions.",
          url: "#",
          source: "BlockchainInsider",
          publishedAt: new Date(Date.now() - 86400000).toISOString(), // 1 day ago
          categories: ["ethereum", "technology", "upgrade"],
        },
        {
          id: "3",
          title: "DeFi Protocol Launches New Governance Token",
          summary: "A leading DeFi protocol has launched a new governance token, giving users more control over the future development of the platform.",
          url: "#",
          source: "DeFiDaily",
          publishedAt: new Date(Date.now() - 172800000).toISOString(), // 2 days ago
          categories: ["defi", "tokens", "governance"],
        },
        {
          id: "4",
          title: "NFT Market Shows Signs of Recovery After Slump",
          summary: "The NFT market is showing signs of recovery with increasing trading volumes after months of declining activity and prices.",
          url: "#",
          source: "NFTWorld",
          publishedAt: new Date(Date.now() - 259200000).toISOString(), // 3 days ago
          categories: ["nft", "market", "trends"],
        },
        {
          id: "5",
          title: "Central Banks Accelerate CBDC Development",
          summary: "Several central banks worldwide are accelerating their central bank digital currency (CBDC) development efforts in response to the growing popularity of cryptocurrencies.",
          url: "#",
          source: "GlobalCryptoNews",
          publishedAt: new Date(Date.now() - 345600000).toISOString(), // 4 days ago
          categories: ["cbdc", "regulation", "government"],
        },
      ];
      
      if (category && category !== "all") {
        const filteredNews = mockNews.filter(item => 
          item.categories.includes(category as string)
        );
        return res.json(filteredNews);
      }
      
      res.json(mockNews);
    } catch (error) {
      res.status(400).json({ error: (error as Error).message });
    }
  });
  
  // Stripe payment routes
  if (stripe) {
    // Create payment intent for one-time payments
    app.post("/api/create-payment-intent", async (req, res) => {
      try {
        const { amount } = req.body;
        
        if (!amount || isNaN(amount)) {
          return res.status(400).json({ error: "Valid amount is required" });
        }
        
        const paymentIntent = await stripe.paymentIntents.create({
          amount: Math.round(amount * 100), // Convert to cents
          currency: "usd",
        });
        
        res.json({ clientSecret: paymentIntent.client_secret });
      } catch (error: any) {
        res.status(500).json({ error: `Error creating payment intent: ${error.message}` });
      }
    });
    
    // Create subscription
    app.post('/api/create-subscription', async (req, res) => {
      try {
        const { email, name, paymentMethodId, priceId } = req.body;
        
        if (!email || !paymentMethodId || !priceId) {
          return res.status(400).json({ error: "Email, payment method, and price ID are required" });
        }
        
        // Create or get customer
        let customer;
        const existingCustomers = await stripe.customers.list({ email });
        
        if (existingCustomers.data.length > 0) {
          customer = existingCustomers.data[0];
        } else {
          customer = await stripe.customers.create({
            email,
            name,
            payment_method: paymentMethodId,
            invoice_settings: { default_payment_method: paymentMethodId },
          });
        }
        
        // Create subscription
        const subscription = await stripe.subscriptions.create({
          customer: customer.id,
          items: [{ price: priceId }],
          expand: ['latest_invoice.payment_intent'],
        });
        
        res.json({ 
          subscriptionId: subscription.id,
          clientSecret: (subscription.latest_invoice as any).payment_intent?.client_secret,
        });
      } catch (error: any) {
        res.status(500).json({ error: `Error creating subscription: ${error.message}` });
      }
    });
    
    // Webhook to handle Stripe events
    app.post('/api/stripe-webhook', async (req, res) => {
      const sig = req.headers['stripe-signature'] as string;
      
      let event;
      
      try {
        // This assumes you've set a STRIPE_WEBHOOK_SECRET environment variable
        // and are using Express's body-parser middleware
        if (process.env.STRIPE_WEBHOOK_SECRET) {
          event = stripe.webhooks.constructEvent(
            req.body,
            sig,
            process.env.STRIPE_WEBHOOK_SECRET
          );
        } else {
          // In development, you can skip signature verification
          event = req.body;
        }
        
        // Handle the event
        switch (event.type) {
          case 'payment_intent.succeeded':
            // Handle successful payment
            console.log('Payment succeeded:', event.data.object.id);
            break;
          case 'invoice.payment_succeeded':
            // Handle successful subscription payment
            console.log('Subscription payment succeeded:', event.data.object.id);
            break;
          // Handle other event types as needed
          default:
            console.log(`Unhandled event type ${event.type}`);
        }
        
        res.json({ received: true });
      } catch (error: any) {
        console.error('Webhook error:', error.message);
        res.status(400).send(`Webhook Error: ${error.message}`);
      }
    });
  } else {
    // If Stripe is not initialized, return error messages for Stripe endpoints
    const stripeErrorHandler = (_req: any, res: any) => {
      res.status(500).json({ error: "Stripe is not configured. Please provide STRIPE_SECRET_KEY." });
    };
    
    app.post("/api/create-payment-intent", stripeErrorHandler);
    app.post("/api/create-subscription", stripeErrorHandler);
    app.post("/api/stripe-webhook", stripeErrorHandler);
  }
  
  return httpServer;
}
